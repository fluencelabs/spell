import PeerSpell from "@fluencelabs/spell/api.aqua"
import TriggerConfig, Spell from "@fluencelabs/spell/spell_service.aqua"
import SpellID from "@fluencelabs/spell/types.aqua"
import Srv from "@fluencelabs/aqua-lib/builtin.aqua"
import DealWorker as Worker from "@fluencelabs/aqua-lib/workers.aqua"
import Ipfs from "@fluencelabs/aqua-ipfs/ipfs.aqua"

import IpfsClient, upload_script from "./files.aqua"
import WorkerSpellArgs, CID, WorkerID, Address, Multiaddr from "./types.aqua"
import IPFS, AppDeployDefinition, DeployedAppWorkers, DeployedSpell, DeployedWorkers from "./config.aqua"
import Json from "./json.aqua"
import Console from "./console.aqua"


func deploy_single_worker(
    air: string,
    trigger_config: TriggerConfig,
    ipfs: Multiaddr,
    worker_name: string,
    worker_definition: CID,
    dummy_deal_id: string
) -> SpellID, WorkerID:
    -- prepare spell arguments
    init_args = WorkerSpellArgs(ipfs = ipfs, worker_def_cid = worker_definition, deal_id = dummy_deal_id)

    worker_id: ?WorkerID
    spell_id: ?SpellID

    -- create Worker or retrieve an existing one via dummy DEAL_ID
    try:
        worker_id <- Worker.create(?[dummy_deal_id])
    catch e:
        worker_id <- Worker.get_peer_id(?[dummy_deal_id])

    on worker_id!:
        -- Take existing worker-spell or create a new one
        try:
            resolved_spell_id <- Srv.resolve_alias("worker-spell")
            -- If spell already exists, update 'worker_def_cid' arg in its KV
            app_cid <- Json.stringify(worker_definition)
            Spell resolved_spell_id
            Spell.set_string("worker_def_cid", app_cid)
            spell_id <<- resolved_spell_id
        catch e:
            -- Create new spell, 'worker_def_cid' will be passed in init_args
            new_spell_id <- PeerSpell.install(air, init_args, trigger_config)
            Srv.add_alias("worker-spell", new_spell_id)
            spell_id <<- new_spell_id

    <- spell_id!, worker_id!

func deploy(config: AppDeployDefinition) -> DeployedAppWorkers:
    workers: *DeployedWorkers
    for w <- config.workers:
        spells: *DeployedSpell
        for h <- w.hosts:
            on h:
                ipfs <- Ipfs.get_local_api_multiaddr()
                spell_id, worker_id <- deploy_single_worker(
                    config.installation_script,
                    config.installation_trigger,
                    ipfs.multiaddr,
                    w.name,
                    w.definition,
                    w.dummy_deal_id
                )
                spells <<- DeployedSpell(spell_id = spell_id, worker_id = worker_id, host_id = h)
                on INIT_PEER_ID via HOST_PEER_ID:
                    co Console.print(["deployed spell", spell_id, worker_id, "to", h])

        workers <<- DeployedWorkers(name = w.name, installation_spells = spells, definition = w.definition, dummy_deal_id = w.dummy_deal_id)
        on INIT_PEER_ID via HOST_PEER_ID:
            co Console.print(["deployed workers", workers])

    deployed = DeployedAppWorkers(workers = workers)
    <- deployed

data RemovedWorker:
    name: string
    worker_ids: []string

-- remove deployed workers
func remove(workers: DeployedAppWorkers) -> []RemovedWorker:
    removed_workers: *RemovedWorker
    for w <- workers.workers:
        removed_worker_ids: *string
        for h <- w.installation_spells:
            on h.host_id:
                Worker.remove(h.worker_id)
                removed_worker_ids <<- h.worker_id
                co Console.print(["removed worker", h.worker_id, "from", h.host_id])
        removed_workers <<- RemovedWorker(name = w.name, worker_ids = removed_worker_ids)

    co Console.print(["workers successfully removed"])
    <- removed_workers
