import PeerSpell from "@fluencelabs/spell/api.aqua"
import TriggerConfig, Spell from "@fluencelabs/spell/spell_service.aqua"
import SpellID from "@fluencelabs/spell/types.aqua"
import Srv from "@fluencelabs/aqua-lib/builtin.aqua"

import IpfsClient, upload_script from "./files.aqua"
import WorkerSpellArgs, CID, WorkerID, Address, Multiaddr from "./types.aqua"
import IPFS, AppDeployDefinition, DeployedAppWorkers, DeployedSpell, DeployedWorkers from "./config.aqua"
import Json from "./json.aqua"
import Console from "./console.aqua"

const DEAL_ID = "dummy-deal-id-123"

-- Direct Hostring Worker API
service Worker("worker"):
  -- throws exception if the worker already exists
  create() -> string
  -- throws exception if the worker doesn't exist
  get_peer_id() -> string

func deploy_single_worker(
    air: string,
    trigger_config: TriggerConfig,
    ipfs: Multiaddr,
    worker_name: string,
    worker_definition: CID
) -> SpellID, WorkerID:
    -- prepare spell arguments
    init_args = WorkerSpellArgs(ipfs = ipfs, worker_def_cid = worker_definition, deal_id = DEAL_ID)

    worker_id: ?WorkerID
    spell_id: ?SpellID

    -- create Worker or retrieve an existing one via dummy DEAL_ID
    try:
        worker_id <- Worker.create()
    catch e:
        worker_id <- Worker.get_peer_id()

    on worker_id!:
        -- Take existing worker-spell or create a new one
        try:
            resolved_spell_id <- Srv.resolve_alias("worker-spell")
            -- If spell already exists, update 'worker_def_cid' arg in its KV
            app_cid <- Json.stringify(worker_definition)
            Spell resolved_spell_id
            Spell.set_string("worker_def_cid", app_cid)
            spell_id <<- resolved_spell_id
        catch e:
            -- Create new spell, 'worker_def_cid' will be passed in init_args
            new_spell_id <- PeerSpell.install(air, init_args, trigger_config)
            Srv.add_alias("worker-spell", new_spell_id)
            spell_id <<- new_spell_id

    <- spell_id!, worker_id!

func deploy(config: AppDeployDefinition) -> DeployedAppWorkers:
    workers: *DeployedWorkers
    for w <- config.workers:
        spells: *DeployedSpell
        for h <- w.hosts:
            on h:
                spell_id, worker_id <- deploy_single_worker(
                    config.installation_script,
                    config.installation_trigger,
                    config.ipfs,
                    w.name,
                    w.definition
                )
                spells <<- DeployedSpell(spell_id = spell_id, worker_id = worker_id, host_id = h)
                on INIT_PEER_ID via HOST_PEER_ID:
                    co Console.print(["deployed spell", spell_id, worker_id, "to", h])

        workers <<- DeployedWorkers(name = w.name, installation_spells = spells, definition = w.definition)
        on INIT_PEER_ID via HOST_PEER_ID:
            co Console.print(["deployed workers", workers])

    deployed = DeployedAppWorkers(workers = workers)
    <- deployed


-- TODO:
-- func remove(worker: WorkerId)