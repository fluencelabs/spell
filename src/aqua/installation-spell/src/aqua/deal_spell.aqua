import Op, Debug, Hash, Dist, Srv, PeerId from "@fluencelabs/aqua-lib/builtin.aqua"
import Ipfs from "@fluencelabs/aqua-ipfs/ipfs.aqua"
import Spell from "@fluencelabs/spell/spell_service.aqua"
import Registry from "@fluencelabs/registry/registry-service.aqua"
import resolveResource from "@fluencelabs/registry/resources-api.aqua"
import getInsecuredPeerId, createSubnetwork, registerWorker from "@fluencelabs/registry/subnetwork.aqua"

import JsonStr, ModuleConfigJson from "./json.aqua"
import Address, Multiaddr, CID, WorkerSpellArgs from "./types.aqua"
import Console from "./console.aqua"
import is_deployed, install from "./spell.aqua"
import SpellData from "./spell_data.aqua"
import log from "./log.aqua"

const DISCOVERY_TIMEOUT_SEC = 43200

service Scope("scope"):
    get_peer_id() -> PeerId

func create_sub(deal_id: string) -> ?string, *string:
    subnet_id, errors <- createSubnetwork(deal_id)
    <- subnet_id, errors

func resolve_workers(deal_id: Address):
    on HOST_PEER_ID:
        peer_id <- getInsecuredPeerId()
        id <- Registry.get_key_id(deal_id, peer_id)
        records, errors <- resolveResource(id, 1)

    Console.print("records:")
    for r <- records!:
        Console.print(r.metadata.copy(issuer_signature = []))

    Console.print("errors:")
    Console.print(errors)

-- A hack to allow using timestamp as u32 values
-- Aqua doesn't allow truncating values
service PeerTimeTrunc("peer"):
    timestamp_sec() -> u32

-- this is executed inside Deal Installation Spell
func deal_install(ipfs: Multiaddr, worker_def_cid: CID, deal_id: Address):
    spell_id <- SpellData.spell_id()
    Spell spell_id

    worker_spell: ?string
    try:
        worker_spell <- Srv.resolve_alias("worker-spell")
    catch e:
        worker_spell <<- spell_id

        try:
            -- if alias isn't set, then set it as early as possible
            Srv.add_alias("worker-spell", spell_id)
            log(["alias created 'worker-spell'", spell_id])
        catch add_err:
            log(["error creating alias", add_err])

    if worker_spell! != spell_id:
        log(["Another worker spell is deployed on this worker (existing, current)", worker_spell!, spell_id])
    else:
        log(["Installing worker for deal", deal_id])
        install(ipfs, worker_def_cid)
        status <- Spell.get_string("status")
        log(["Worker installation finished with status", status.str])

        if status.str == "install finished":
            subnet_id: ?string

            now <- PeerTimeTrunc.timestamp_sec()
            created <- Spell.get_u32("subnet_created")
            registered <- Spell.get_u32("worker_registered")
            if created.success:
                if registered.success:
                    if now - created.num > DISCOVERY_TIMEOUT_SEC:
                        -- Create subnet only if DISCOVERY_TIMEOUT_SEC has passed
                        new_subnet_id, cre_errs <- createSubnetwork(deal_id)
                        if new_subnet_id != nil:
                            log(["Subnet created", subnet_id])
                            subnet_id <<- new_subnet_id!
                        else:
                            log(["error creating subnetwork", cre_errs])

                    else:
                        if now - registered.num > DISCOVERY_TIMEOUT_SEC:
                            sid <- Spell.get_string("subnet_id")
                            if sid.success:
                                -- Set subnet_id only if DISCOVERY_TIMEOUT_SEC has passed
                                -- Intention is to rate limit 'registerWorker' call
                                subnet_id <<- sid.str
                            else:
                                log(["error reading subnet_id", sid])
                else:
                    log(["error reading worker_registered", registered])
            else:
                log(["error reading subnet_created", created])

            -- subnet_id will be 'nil' if DISCOVERY_TIMEOUT_SEC has not yet passed
            if subnet_id != nil:
                Spell.set_string("subnet_id", subnet_id!)
                Spell.set_u32("subnet_created", now)
                on HOST_PEER_ID:
                    success, reg_errs <- registerWorker(subnet_id!)
                if success == true:
                    Spell.set_u32("worker_registered", now)
                    log(["worker successfully registered in registry", success])
                else:
                    log(["error registering worker", reg_errs])

