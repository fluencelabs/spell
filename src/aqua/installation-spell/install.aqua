import "@fluencelabs/spell/api.aqua"
import "@fluencelabs/spell/spell_service.aqua"
-- import IpfsClient from "/Users/folex/Development/fluencelabs/iceland/indexer_workshop/src/aqua/services.aqua"
import "@fluencelabs/aqua-ipfs/ipfs-api.aqua"
import "@fluencelabs/aqua-ipfs/ipfs.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"

alias CID: string
alias Path: string
alias Multiaddr: string
alias JsonString: string

service IpfsClient("ipfs_client"):
    id(multiaddr: string) -> string
    exists(multiaddr: string, cid: CID) -> bool
    upload(multiaddr: string, path: string) -> CID
    upload_string(multiaddr: string, contents: string) -> CID
    remove(multiaddr: string, cid: CID) -> string

service FileSystem("file_system"):
    list(directory: string) -> []Path
    list_ext(directory: string, ext: string) -> []Path

data Module:
    wasm: CID
    config: CID

data Service:
    name: string
    modules: []Module

data TriggerConfig:
    time: string

data Spell:
    script: string
    config: TriggerConfig

data RemoteAppConfig:
    services: []Service
    spells: []Spell

service RACJson("json"):
    stringify(rac: RemoteAppConfig) -> JsonString
    parse(json: JsonString) -> RemoteAppConfig


data LocalModule:
    wasm: Path
    config: Path

data LocalService:
    name: string
    modules: []LocalModule

data LocalAppConfig:
    basedir: Path
    services: []LocalService
    -- spells: []Spell

service ModuleConfigJson("json"):
    parse(json: JsonString) -> ModuleConfig


alias DynamicJsonObjHack: string
service Json("json"):
    obj_pairs(pairs: [][]string) -> DynamicJsonObjHack

service MOp("op"):
    identity(modules: []Module) -> []Module

service SOp("op"):
    identity(services: []Service) -> []Service

func upload_app_config(ipfs: Multiaddr, config: LocalAppConfig) -> CID:
    services: *Service
    for s <- config.services:
        modules: *Module
        for m <- s.modules:
            wasm <- IpfsClient.upload(ipfs, Op.concat_strings(config.basedir, m.wasm))
            cfg <- IpfsClient.upload(ipfs, Op.concat_strings(config.basedir, m.config))
            modules <<- Module(wasm = wasm, config = cfg)
        services <<- Service(name = s.name, modules = modules)
    rac = RemoteAppConfig(services = services, spells = [])
    json <- RACJson.stringify(rac)
    cid <- IpfsClient.upload_string(ipfs, json)
    <- cid

func upload_to_relay(config: LocalAppConfig) -> CID:
    on HOST_PEER_ID:
        ipfs <- get_external_api_multiaddr(HOST_PEER_ID)
        <- upload_app_config(ipfs.multiaddr, config)


service Console("run-console"):
    print(s: string)


func install(ipfs: Multiaddr, app_config_json: CID) -> DynamicJsonObjHack:
    on HOST_PEER_ID:
        json <- Ipfs.cat_from(app_config_json, ipfs)
        app_config <- RACJson.parse(json.contents)
        on INIT_PEER_ID:
            co Console.print(Debug.stringify(app_config))

        services: *[]string
        for s <- app_config.services:
            -- TODO: check that service was not deployed yet
            -- TODO: check that blueprint_id was not changed

            hashes: *Hash
            for m <- s.modules:
                get_wasm <- Ipfs.get_from(m.wasm, ipfs)
                json_cfg <- Ipfs.cat_from(m.config, ipfs)
                cfg <- ModuleConfigJson.parse(json_cfg.contents)
                hash <- Dist.add_module_from_vault(get_wasm.path, cfg)
                on INIT_PEER_ID:
                    co Console.print(Debug.stringify([cfg, hash]))
                hashes <- Op.concat_strings("hash:", hash)
            blueprint <- Dist.make_blueprint(s.name, hashes)
            on INIT_PEER_ID:
                    co Console.print(Debug.stringify(blueprint))
            blueprint_id <- Dist.add_blueprint(blueprint)
            service_id <- Srv.create(blueprint_id)
            services <<- [s.name, service_id]
        obj <- Json.obj_pairs(services)

        -- Manual set:
        -- Spell spell_id
        -- Spell.set_string(s.name, service_id)

    -- Automatic set:
    Console.print(Debug.stringify(obj))
    <- obj

func install_to_relay(app_config_json: CID) -> DynamicJsonObjHack:
    on HOST_PEER_ID:
        ipfs <- get_external_api_multiaddr(HOST_PEER_ID)
        <- install(ipfs.multiaddr, app_config_json)

func upstall(config: LocalAppConfig) -> DynamicJsonObjHack:
    cid <- upload_to_relay(config)
    <- install_to_relay(cid)
