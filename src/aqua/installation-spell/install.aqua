import "@fluencelabs/spell/api.aqua"
import "@fluencelabs/spell/spell_service.aqua"
-- import IpfsClient from "/Users/folex/Development/fluencelabs/iceland/indexer_workshop/src/aqua/services.aqua"
import "@fluencelabs/aqua-ipfs/ipfs-api.aqua"
import "@fluencelabs/aqua-ipfs/ipfs.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"

alias CID: string
alias Path: string
alias Multiaddr: string
alias JsonString: string

service IpfsClient("ipfs_client"):
    id(multiaddr: string) -> string
    exists(multiaddr: string, cid: CID) -> bool
    upload(multiaddr: string, path: string) -> CID
    upload_string(multiaddr: string, contents: string) -> CID
    remove(multiaddr: string, cid: CID) -> string

service FileSystem("file_system"):
    list(directory: string) -> []Path
    list_ext(directory: string, ext: string) -> []Path

data Module:
    wasm: CID
    config: CID

data Service:
    name: string
    modules: []Module

data Spell:
    script: string
    config: TriggerConfig

data RemoteAppConfig:
    services: []Service
    spells: []Spell

service RACJson("json"):
    stringify(rac: RemoteAppConfig) -> JsonString
    parse(json: JsonString) -> RemoteAppConfig


data LocalModule:
    wasm: Path
    config: Path

data LocalService:
    name: string
    modules: []LocalModule

data LocalAppConfig:
    basedir: Path
    services: []LocalService
    -- spells: []Spell

service ModuleConfigJson("json"):
    parse(json: JsonString) -> ModuleConfig


alias DynamicJsonObjHack: string
service Json("json"):
    obj_pairs(pairs: [][]string) -> DynamicJsonObjHack
    stringify(obj: DynamicJsonObjHack) -> JsonString

service MOp("op"):
    identity(modules: []Module) -> []Module

service SOp("op"):
    identity(services: []Service) -> []Service

func upload_app_config(ipfs: Multiaddr, config: LocalAppConfig) -> CID:
    services: *Service
    for s <- config.services:
        modules: *Module
        for m <- s.modules:
            wasm <- IpfsClient.upload(ipfs, Op.concat_strings(config.basedir, m.wasm))
            cfg <- IpfsClient.upload(ipfs, Op.concat_strings(config.basedir, m.config))
            modules <<- Module(wasm = wasm, config = cfg)
        services <<- Service(name = s.name, modules = modules)
    rac = RemoteAppConfig(services = services, spells = [])
    json <- RACJson.stringify(rac)
    cid <- IpfsClient.upload_string(ipfs, json)
    <- cid

func upload_to_relay(config: LocalAppConfig) -> CID:
    on HOST_PEER_ID:
        ipfs <- get_external_api_multiaddr(HOST_PEER_ID)
        <- upload_app_config(ipfs.multiaddr, config)


service Console("run-console"):
    print(s: string)

service Wtf("wtf"):
    wtf()

service JsonStr("json"):
    parse(s: JsonString) -> string

service SpellData("getDataSrv"):
    spell_id() -> string

func blueprint_key(service_name: string) -> string:
    <- Op.concat_strings("blueprint:", service_name)

-- returns 'true' if service is in spell KV and has the same blueprint_id
-- returns 'false' otherwise
func is_deployed(service_name: string, blueprint_id: string) -> bool:
    result: ?bool

    spell_id <- SpellData.spell_id()
    Spell spell_id
    deployed <- Spell.exists(service_name)
    if deployed.flag:
        stored_blueprint <- Spell.get_string(blueprint_key(service_name))
        if stored_blueprint.str == blueprint_id:
            result <<- true
        else:
            result <<- false
        Console.print(Debug.stringify([deployed, stored_blueprint, blueprint_id, result]))
    else:
        result <<- false

    <- result!

data InstallSpellArgs:
    ipfs: Multiaddr
    app_config_json: CID

func install(ipfs: Multiaddr, app_config_json: CID):
    spell_id <- SpellData.spell_id()
    ipfs_maddr <- JsonStr.parse(ipfs)
    app_config_json_parsed <- JsonStr.parse(app_config_json)
    on HOST_PEER_ID:
        -- download App Config from IPFS
        json <- Ipfs.cat_from(app_config_json_parsed, ipfs_maddr)
        if json.success:
            app_config <- RACJson.parse(json.contents)
            on INIT_PEER_ID:
                co Console.print(Debug.stringify(app_config))

            for s <- app_config.services:
                hashes: *Hash
                for m <- s.modules:
                    get_wasm <- Ipfs.get_from(m.wasm, ipfs_maddr)
                    json_cfg <- Ipfs.cat_from(m.config, ipfs_maddr)
                    cfg <- ModuleConfigJson.parse(json_cfg.contents)
                    hash <- Dist.add_module_from_vault(get_wasm.path, cfg)
                    on INIT_PEER_ID:
                        co Console.print(Debug.stringify([cfg, hash]))
                    hashes <- Op.concat_strings("hash:", hash)

                blueprint <- Dist.make_blueprint(s.name, hashes)
                blueprint_id <- Dist.add_blueprint(blueprint)

                -- do not deploy if already deployed with the same blueprint
                if is_deployed(s.name, blueprint_id) == false:
                    service_id <- Srv.create(blueprint_id)
                    Spell spell_id
                    Spell.set_string(s.name, service_id)
                    Spell.set_string(blueprint_key(s.name), blueprint_id)
                else:
                    Console.print(Op.concat_strings(s.name, " is already deployed"))

func install_to_relay(app_config_json: CID):
    on HOST_PEER_ID:
        ipfs <- get_external_api_multiaddr(HOST_PEER_ID)
        install(ipfs.multiaddr, app_config_json)

func upstall(config: LocalAppConfig):
    cid <- upload_to_relay(config)
    install_to_relay(cid)

service ISAJson("json"):
    stringify(isa: InstallSpellArgs) -> JsonString

service Cast("op"):
    identity(long: u64) -> u32

func upload_script(ipfs: Multiaddr, path: Path) -> CID:
    <- IpfsClient.upload(ipfs, path)

func oneshot() -> TriggerConfig:
    now <- Cast.identity(Peer.timestamp_sec())
    oneshot = ClockConfig(start_sec = now, end_sec = now + 1, period_sec = 0)
    e1 = ConnectionPoolConfig(connect = false, disconnect = false)
    e2 = BlockChainConfig(start_block = 0, end_block = 0)
    <- TriggerConfig(clock = oneshot, connections = e1, blockchain = e2)

func times(times: u32, period: u32) -> TriggerConfig:
    now <- Cast.identity(Peer.timestamp_sec())
    clock = ClockConfig(start_sec = now, end_sec = now + (period * times), period_sec = period)

    e1 = ConnectionPoolConfig(connect = false, disconnect = false)
    e2 = BlockChainConfig(start_block = 0, end_block = 0)
    <- TriggerConfig(clock = clock, connections = e1, blockchain = e2)

func upstall_spell_to_relay(script: Path, config: LocalAppConfig) -> string:
    -- upload
    on HOST_PEER_ID:
        ipfs <- get_external_api_multiaddr(HOST_PEER_ID)
    config_cid <- upload_app_config(ipfs.multiaddr, config)
    script_cid <- upload_script(ipfs.multiaddr, script)
    Console.print(ipfs.multiaddr)

    on HOST_PEER_ID:
        -- install
        init_args = InstallSpellArgs(ipfs = ipfs.multiaddr, app_config_json = config_cid)
        init_args_json <- ISAJson.stringify(init_args)
        air <- Ipfs.cat_from(script_cid, ipfs.multiaddr)

        on INIT_PEER_ID:
            co Console.print(init_args_json)

        -- TODO: rename PeerSpell to SpellControl
        trig_conf <- times(10, 5)
        spell_id <- PeerSpell.install(air.contents, init_args_json, trig_conf)
        <- spell_id
