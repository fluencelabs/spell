aqua Lib declares *

export list_spells, install, remove, update, get_config, get_script, get_counter, get_string
export is_spell_absent, get_trigger_event, get_all_trigger_events, remove_service, get_location, get_spell_errors, noop
export get_worker_spell_status, set_worker_spell_status, get_worker_spell_statuses_from, set_spell_alias

import "../../src/aqua/spell/api.aqua"
import "../../src/aqua/spell/trigger.aqua"
import "../../src/aqua/spell/types.aqua"
import "../../src/aqua/spell/spell_service.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"
import Worker from "@fluencelabs/aqua-lib/workers.aqua"
import "../../src/aqua/installation-spell/src/aqua/status.aqua"
import "../../src/aqua/installation-spell/src/aqua/types.aqua"
import "../../src/aqua/installation-spell/src/aqua/json.aqua"

const DUMMY_DEAL_ID = "dummy-deal-id"

func get_worker_id() -> string:
    worker_id: *string
    deal_id <- Op.concat_strings(DUMMY_DEAL_ID, INIT_PEER_ID)
    existing_worker <- Worker.get_worker_id(deal_id)
    if existing_worker == nil:
        worker_id <- Worker.create(deal_id)
    else:
        worker_id <<- existing_worker!
    <- worker_id!

func list_spells() -> []string:
    on HOST_PEER_ID:
        worker_id <- get_worker_id()
        on worker_id:
            res <- PeerSpell.list()
    <- res

data InstallResult:
  success: bool
  error: string
  spell_id: string

func install(script: string, cfg: TriggerConfig, dat: âŠ¤, name: string) -> InstallResult:
    result: *InstallResult
    on HOST_PEER_ID:
        worker_id <- get_worker_id()
        on worker_id via HOST_PEER_ID:
            try:
                sid <- PeerSpell.install(script, dat, cfg, name)
                result <<- InstallResult(success = true, error = "", spell_id = sid)
            catch err:
                result <<- InstallResult(success = false, error = err.message, spell_id = "")
    <- result[0]

data Result:
  success: bool
  error: string

func remove(spell_id: string) -> Result:
    result: *Result
    on HOST_PEER_ID:
        worker_id <- get_worker_id()
        on worker_id via HOST_PEER_ID:
            try:
                PeerSpell.remove(spell_id)
                result <<- Result(success = true, error = "")
            catch err:
                result <<- Result(success = false, error = err.message)
    <- result[0]

func update(spell_id: string, config: TriggerConfig) -> Result:
   result: *Result
   on HOST_PEER_ID:
     worker_id <- get_worker_id()
     on worker_id via HOST_PEER_ID:
        try:
            PeerSpell.update_trigger_config(spell_id, config)
            result <<- Result(success = true, error = "")
        catch err:
            result <<- Result(success = false, error = err.message)
   <- result[0]

func get_config(spell_id: string) -> TriggerConfigValue:
    on HOST_PEER_ID:
        Spell spell_id
        cfg <- Spell.get_trigger_config()
    <- cfg

func get_script(spell_id: string) -> ScriptValue:
    on HOST_PEER_ID:
        Spell spell_id
        cfg <- Spell.get_script_source_from_file()
    <- cfg

func get_counter(spell_id: string) -> U32Value:
    on HOST_PEER_ID:
        Spell spell_id
        count <- Spell.get_u32("counter")
    <- count

func get_location(spell_id: string) -> LocationValue:
    on HOST_PEER_ID:
        Spell spell_id
        count <- Spell.get_location()
    <- count

-- For a test we want to retrive these values at the same time
func get_string(spell_id: string, key: string) -> StringValue:
    on HOST_PEER_ID:
        Spell spell_id
        value <- Spell.get_string("value")
    <- value

func is_spell_absent(spell_id: string) -> bool:
  result: *bool
  on HOST_PEER_ID:
    try:
        Spell spell_id
        Spell.get_trigger_config()
        result <<- false
    otherwise:
        result <<- true
  <- result[0]

func remove_service(id: string) -> Result:
   result: *Result
   on HOST_PEER_ID:
      try:
          Srv.remove(id)
          result <<- Result(success = true, error = "")
      catch err:
          result <<- Result(success = false, error = err.message)
   <- result[0]

func get_trigger_event(spell_id: string) -> ?TriggerEvent, ?string:
    error: *string
    trigger: *TriggerEvent
    on HOST_PEER_ID:
        Spell spell_id
        result <- Spell.get_string("trigger")
        if result.success:
            if result.absent == false:
                trigger <- TriggerEventJson.parse(result.str)
        else:
            error <<- result.error

    <- trigger, error

-- you should store triggers in KV;
-- to achieve this you can use store_triggers_script from test_aqua.py
func get_all_trigger_events(spell_id: string) -> []TriggerEvent, ?string:
    error: *string
    triggers: *TriggerEvent
    on HOST_PEER_ID:
        Spell spell_id
        result <- Spell.list_get_strings("triggers")
        if result.success:
            for trigger <- result.strings:
                triggers <- TriggerEventJson.parse(trigger)
        else:
            error <<- result.error

    <- triggers, error

func get_spell_errors(spell_id: string) -> AllErrorsResult:
    on HOST_PEER_ID:
        Spell spell_id
        x <- Spell.get_all_errors()
    <- x

func noop():
	on HOST_PEER_ID:
		Op.noop()

func set_spell_alias(alias: string, spell_id: string) -> Result:
    result: *Result
    on HOST_PEER_ID:
        worker_id <- get_worker_id()
        on worker_id via HOST_PEER_ID:
            try:
                Srv.add_alias(alias, spell_id)
                result <<- Result(success = true, error = "")
            catch err:
                result <<- Result(success = false, error = err.message)
    <- result!

func set_worker_spell_status(state: State, message: string) -> string:
    on HOST_PEER_ID:
        worker_id <- get_worker_id()
        on worker_id via HOST_PEER_ID:
            set_status_msg(state, message)
            -- HACK: we need to return smth, because otherwise particle won't be processed at all
            -- and we receive an error:
            -- `particle_protocol::libp2p_protocol::upgrade: Error processing inbound ProtocolMessage: unexpected end of file
            -- Location: /opt/actions-runner/_work/nox/nox/particle-protocol/src/libp2p_protocol/upgrade.rs:119:27`
    <- "OK"

func get_worker_spell_status() -> Status:
    on HOST_PEER_ID:
        worker_id <- get_worker_id()
        on worker_id via HOST_PEER_ID:
            status <- get_status()
    <- status

func get_worker_spell_statuses_from(timestamp: u64) -> []Status:
    on HOST_PEER_ID:
        worker_id <- get_worker_id()
        on worker_id via HOST_PEER_ID:
            statuses <- get_statuses_from(timestamp)
    <- statuses
